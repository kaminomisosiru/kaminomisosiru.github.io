---
layout: post
css-include: diary
---

格子暗号で使われている多項式の積の計算と数論変換(Number Theoretic Transform; NTT)についてのメモ。

### 概要

$d$を2のべき乗(e.g., 128, 256), $q$を素数、$f(X) = X^d+1$とする。
剰余多項式環$R_q = Z_q[X]/f(X)$を考える。
教科書的に多項式$a, b \in R_q$の積$ab$を計算しようとすると$O(d^{2})$回の乗算が必要だが、数論上の性質をうまく使うと$O(d\log d)$回の乗算で積を計算できる。

まず、大雑把なアイデアを紹介する。
$q \equiv 1 \bmod 2d$が成り立つとき、$r^{d} \equiv -1 \bmod q$を満たす$r$, つまり$-1$の原始$d$乗根がちょうど$d$個存在する。
$-1$の原始$d$乗根の集合を$S^{(d)} = \\{r_i \mid r^{d}_i \equiv -1 \bmod q\\}$とすると、$f(X)$を次のように因数分解できる。

$$
f(X) = (X - r_1)(X - r_2)\cdots(X - r_d)
$$

すると、中国の剰余定理より多項式$a \in R_q$は次のようなベクトルで表現できる。

$$
\hat{a} = (a \bmod X- r_1, a \bmod X - r_2, \cdots, a \bmod X - r_d)
$$

従って、多項式 $a, b \in R_q$の積$ab$は次の手順で計算できる。

1. $a, b$をベクトル表現$\hat{a}, \hat{b}$に変換する。(この変換をNTTと呼ぶらしい)
2. $\hat{a}, \hat{b}$の要素ごとに積を計算し、$\hat{ab}$を得る。
3. ベクトル表現$\hat{ab}$を多項式表現$ab$へ逆変換する。

$\hat{a}, \hat{b}$の長さは$d$であるから、step 2は$d$回の乗算で実行できる。
以降、step 1, 3で必要な計算量を考える。

今、$d$は偶数であるから、$r \in S^{(d)}$ならば、$-r \in S^{(d)}$である。
また、$r^{2} \in S^{(d/2)}$, $-r^{2} \in S^{(d/2)}$である。
帰納的に考えると、全ての$d \geq 2$について$\pm r \in S^{(d)}$, $\pm r^{2} \in S^{(d/2)}$が言える。

以上の性質を用いることで次のように$a \in R_q$のベクトル表現$\hat{a}$を計算できる。

$\pm r \in S^{(d)}$より、$f(X)$を次のように書き直すことができる。

$$
\begin{align*}
X^{d}+1 &= (X - r_1)(X + r_1)(X - r_2)(X + r_2)\cdots(X - r_{d/2})(X + r_{d/2})\\
&= (X^2 - r^{2}_{1})(X^2 - r^{2}_{2})\cdots(X^2 - r^{2}_{d/2})
\end{align*}
$$

$r^{2}_{i} \in S^{(d/2)}$であるから、同様の議論を繰り返すことで次の式を得る。

$$
\begin{aligned}
X^{d}+1 &=\left(X-r_{1}\right)\left(X+r_{1}\right)\left(X-r_{2}\right)\left(X+r_{2}\right) \cdots\left(X-r_{d / 2}\right)\left(X+r_{d / 2}\right)\\
&=\left(X^{2}-r_{1}^{2}\right)\left(X^{2}+r_{1}^{2}\right) \cdots\left(X^{2}-r_{d / 4}^{2}\right)\left(X^{2}+r_{d / 4}^{2}\right) \\
&=\left(X^{4}-r_{1}^{4}\right) \cdots\left(X^{4}-r_{d / 4}^{4}\right) \\
&=\left(X^{8}-r_{1}^{8}\right) \cdots\left(X^{8}-r_{d / 8}^{8}\right) \\
& \cdots \\
&=\left(X^{d / 2}-r_{1}^{d / 2}\right)\left(X^{d / 2}-r_{2}^{d / 2}\right)
\end{aligned}
$$

ここで、$r^{d/2}_{2} = -r^{d/2}_{1}$である。つまり、$f(X)$を2つの多項式の積に分解できた。ところで、

$$
(a \bmod X^{d / 2}-r_{1}^{d / 2}, a \bmod X^{d / 2}-r_{2}^{d / 2})
$$

が計算できたならば、この結果を用いて

$$
a \bmod (X^{d / 4} \pm r_{i}^{d / 4}) = a \bmod (X^{d / 2}-r_{i}^{d / 2}) \bmod (X^{d / 4} \pm r_{i}^{d / 4})
$$

として次のレベルを計算できる。これを繰り返すことにより、$a \in R_q$のベクトル表現$\hat{a}$を計算できる。


各レベルでは高々$d$回の乗算(modの計算)を行う。
また、modによって毎回2倍に分割されるので、高々$\log d$回行う。
従って、$a \in R_q$のベクトル表現$\hat{a}$は$d\log d$回の乗算で求める事ができる。

逆変換も同様に$d\log d$回の乗算で求める事ができる。
大雑把にいうととなり同士の要素に関して中国の剰余定理を使って次のレベルの値を復元すればいい。
例えば、$X - r_1$と$X + r_1$は互いに素であるから、$a \bmod X - r_1$と$a \bmod X + r_1$から$a \bmod (X + r_1)(X - r_1)$を求めることができる。
これを$\log d$ステップ行うことで最後には$a \bmod (X^d + 1)$を得られる。

以上より$O(d\log d)$回の乗算で多項式の積を求める事ができる。

### 具体例

あとで追加予定


### 参考資料

+ Lyubashevsky, V.: Basic Lattice Cryptography : Encryption and Fiat-Shamir Signatures. (2019).
+ https://vitalik.ca/general/2019/05/12/fft.html